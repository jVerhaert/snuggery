/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-snuggery-workspace",
factory: function (require) {
var plugin=(()=>{var F=Object.create,P=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var R=Object.getPrototypeOf,H=Object.prototype.hasOwnProperty;var S=r=>P(r,"__esModule",{value:!0});var c=r=>{if(typeof require!="undefined")return require(r);throw new Error('Dynamic require of "'+r+'" is not supported')};var W=(r,t)=>{for(var i in t)P(r,i,{get:t[i],enumerable:!0})},B=(r,t,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of A(t))!H.call(r,o)&&o!=="default"&&P(r,o,{get:()=>t[o],enumerable:!(i=$(t,o))||i.enumerable});return r},p=r=>B(S(P(r!=null?F(R(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var G={};W(G,{default:()=>z});var M=p(c("@yarnpkg/cli")),e=p(c("@yarnpkg/core")),n=p(c("@yarnpkg/fslib")),U=p(c("@yarnpkg/plugin-pack")),D=p(c("clipanion"));var w=p(c("@yarnpkg/core")),E=p(c("@yarnpkg/fslib"));function N(r,t,i){return Object.create(r,{cwd:{value:t,writable:!1,configurable:!0},manifest:{value:w.Manifest.fromText(JSON.stringify(i)),writable:!1,configurable:!0}})}function I(r){return E.xfs.mktempPromise(async t=>{let i=new E.CwdFS(t);return await w.tgzUtils.extractArchiveTo(r,i,{stripComponents:1}),w.Manifest.fromText(await i.readFilePromise(w.Manifest.fileName,"utf8"))})}var x=class extends M.BaseCommand{constructor(){super(...arguments);this.json=D.Option.Boolean("--json");this.directory=D.Option.String({required:!0})}async execute(){let t=await e.Configuration.find(this.context.cwd,this.context.plugins);return(await e.StreamReport.start({configuration:t,stdout:this.context.stdout,includeFooter:!1,includeInfos:!0,json:this.json},async o=>{let{project:y,workspace:s}=await e.Project.find(t,this.context.cwd);if(!s){o.reportError(e.MessageName.UNNAMED,"Couldn't find workspace");return}if(s.manifest.name==null){o.reportError(e.MessageName.UNNAMED,`Package at ${e.formatUtils.pretty(t,s.relativeCwd,e.FormatType.PATH)} doesn't have a name`);return}let m=n.ppath.join(y.cwd,"dist");await n.xfs.mkdirPromise(m,{recursive:!0}),await y.restoreInstallState();let k=n.ppath.join(m,`${e.structUtils.slugifyIdent(s.manifest.name)}.tgz`),d=n.ppath.resolve(s.cwd,n.npath.toPortablePath(this.directory));if(!await n.xfs.existsPromise(d)){o.reportError(e.MessageName.UNNAMED,`Build package ${e.formatUtils.pretty(t,s.manifest.name,e.FormatType.IDENT)} first`);return}let l=await n.xfs.readJsonPromise(n.ppath.join(d,n.Filename.manifest)),g=e.structUtils.parseIdent(l.name);if(g.identHash!==s.anchoredDescriptor.identHash){o.reportError(e.MessageName.UNNAMED,`Invalid distribution folder: found package ${e.formatUtils.pretty(t,g,e.FormatType.IDENT)} but expected ${e.formatUtils.pretty(t,s.anchoredDescriptor,e.FormatType.IDENT)}`);return}let b=N(s,d,l),f=await U.packUtils.genPackStream(b,await U.packUtils.genPackList(b));await n.xfs.writeFilePromise(k,await e.miscUtils.bufferStream(f)),o.reportInfo(null,`Packed ${e.formatUtils.pretty(t,g,e.FormatType.IDENT)} into ${e.formatUtils.pretty(t,k,e.FormatType.PATH)}`)})).exitCode()}};x.paths=[["snuggery-workspace","pack"]];var v=p(c("@yarnpkg/cli")),a=p(c("@yarnpkg/core")),h=p(c("@yarnpkg/fslib")),u=p(c("@yarnpkg/plugin-npm")),j=p(c("clipanion"));var T=class extends v.BaseCommand{constructor(){super(...arguments);this.tag=j.Option.String("--tag","latest");this.json=j.Option.Boolean("--json")}async execute(){let t=await a.Configuration.find(this.context.cwd,this.context.plugins);return(await a.StreamReport.start({configuration:t,stdout:this.context.stdout,json:this.json,includeInfos:!0},async o=>{let{project:y,workspace:s}=await a.Project.find(t,this.context.cwd);if(!s){o.reportError(a.MessageName.UNNAMED,"Couldn't find workspace");return}if(s.manifest.name===null||s.manifest.version===null){o.reportError(a.MessageName.UNNAMED,"Workspaces must have valid names and versions to be published on an external registry");return}let m=s.manifest.name,k=h.ppath.join(y.cwd,"dist",`${a.structUtils.slugifyIdent(m)}.tgz`);if(!await h.xfs.existsPromise(k)){o.reportError(a.MessageName.UNNAMED,`Pack package ${a.formatUtils.pretty(t,m,a.FormatType.IDENT)} first`);return}let d=await h.xfs.readFilePromise(k),l=await I(d);if(l.name==null||l.name.identHash!==m.identHash){o.reportError(a.MessageName.UNNAMED,`Tarball for package ${l.name&&a.formatUtils.pretty(t,l.name,a.FormatType.IDENT)} cannot be published in workspace for ${a.formatUtils.pretty(t,m,a.FormatType.IDENT)}`);return}let g=u.npmConfigUtils.getPublishRegistry(l,{configuration:t}),b=await u.npmPublishUtils.makePublishBody(N(s,s.cwd,l.raw),d,{access:void 0,tag:this.tag,registry:g});try{await u.npmHttpUtils.put(u.npmHttpUtils.getIdentUrl(m),b,{configuration:t,registry:g,ident:m,jsonResponse:!0})}catch(f){if(f.name!=="HTTPError")throw f;{let C=f.response.body&&f.response.body.error?f.response.body.error:`The remote server answered with HTTP ${f.response.statusCode} ${f.response.statusMessage}`;o.reportError(a.MessageName.NETWORK_ERROR,C)}}o.hasErrors()||o.reportInfo(null,`Published ${a.formatUtils.pretty(t,a.structUtils.makeDescriptor(m,l.version),a.FormatType.DESCRIPTOR)}`)})).exitCode()}};T.paths=[["snuggery-workspace","publish"]];var O={commands:process.env.SNUGGERY_YARN==="1"?[x,T]:[]},z=O;return G;})();
return plugin;
}
};
