/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-snuggery-workspace",
factory: function (require) {
var plugin=(()=>{var F=Object.create,P=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var R=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty;var H=r=>P(r,"__esModule",{value:!0});var c=r=>{if(typeof require!="undefined")return require(r);throw new Error('Dynamic require of "'+r+'" is not supported')};var W=(r,t)=>{for(var n in t)P(r,n,{get:t[n],enumerable:!0})},O=(r,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of A(t))!S.call(r,s)&&s!=="default"&&P(r,s,{get:()=>t[s],enumerable:!(n=$(t,s))||n.enumerable});return r},p=r=>O(H(P(r!=null?F(R(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var J={};W(J,{default:()=>z});var M=p(c("@yarnpkg/cli")),e=p(c("@yarnpkg/core")),i=p(c("@yarnpkg/fslib")),U=p(c("@yarnpkg/plugin-pack")),j=p(c("clipanion"));var h=p(c("@yarnpkg/core")),N=p(c("@yarnpkg/fslib"));function E(r,t,n){return Object.create(r,{cwd:{value:t,writable:!1,configurable:!0},manifest:{value:Object.create(r.manifest,{raw:{value:JSON.parse(JSON.stringify(n)),writable:!1,configurable:!0}}),writable:!1,configurable:!0}})}function I(r){return N.xfs.mktempPromise(async t=>{let n=new N.CwdFS(t);return await h.tgzUtils.extractArchiveTo(r,n,{stripComponents:1}),h.Manifest.fromText(await n.readFilePromise(h.Manifest.fileName,"utf8"))})}var x=class extends M.BaseCommand{constructor(){super(...arguments);this.json=j.Option.Boolean("--json");this.directory=j.Option.String({required:!0})}async execute(){let t=await e.Configuration.find(this.context.cwd,this.context.plugins);return(await e.StreamReport.start({configuration:t,stdout:this.context.stdout,includeFooter:!1,includeInfos:!0,json:this.json},async s=>{let{project:y,workspace:o}=await e.Project.find(t,this.context.cwd);if(!o){s.reportError(e.MessageName.UNNAMED,"Couldn't find workspace");return}if(o.manifest.name==null){s.reportError(e.MessageName.UNNAMED,`Package at ${e.formatUtils.pretty(t,o.relativeCwd,e.FormatType.PATH)} doesn't have a name`);return}let m=i.ppath.join(y.cwd,"dist");await i.xfs.mkdirPromise(m,{recursive:!0}),await y.restoreInstallState();let w=i.ppath.join(m,`${e.structUtils.slugifyIdent(o.manifest.name)}.tgz`),d=i.ppath.resolve(o.cwd,i.npath.toPortablePath(this.directory));if(!await i.xfs.existsPromise(d)){s.reportError(e.MessageName.UNNAMED,`Build package ${e.formatUtils.pretty(t,o.manifest.name,e.FormatType.IDENT)} first`);return}let l=await i.xfs.readJsonPromise(i.ppath.join(d,i.Filename.manifest)),g=e.structUtils.parseIdent(l.name);if(g.identHash!==o.anchoredDescriptor.identHash){s.reportError(e.MessageName.UNNAMED,`Invalid distribution folder: found package ${e.formatUtils.pretty(t,g,e.FormatType.IDENT)} but expected ${e.formatUtils.pretty(t,o.anchoredDescriptor,e.FormatType.IDENT)}`);return}let b=E(o,d,l),f=await U.packUtils.genPackStream(b,await U.packUtils.genPackList(b));await i.xfs.writeFilePromise(w,await e.miscUtils.bufferStream(f)),s.reportInfo(null,`Packed ${e.formatUtils.pretty(t,g,e.FormatType.IDENT)} into ${e.formatUtils.pretty(t,w,e.FormatType.PATH)}`)})).exitCode()}};x.paths=[["snuggery-workspace","pack"]];var v=p(c("@yarnpkg/cli")),a=p(c("@yarnpkg/core")),k=p(c("@yarnpkg/fslib")),u=p(c("@yarnpkg/plugin-npm")),D=p(c("clipanion"));var T=class extends v.BaseCommand{constructor(){super(...arguments);this.tag=D.Option.String("--tag","latest");this.json=D.Option.Boolean("--json")}async execute(){let t=await a.Configuration.find(this.context.cwd,this.context.plugins);return(await a.StreamReport.start({configuration:t,stdout:this.context.stdout,json:this.json,includeInfos:!0},async s=>{let{project:y,workspace:o}=await a.Project.find(t,this.context.cwd);if(!o){s.reportError(a.MessageName.UNNAMED,"Couldn't find workspace");return}if(o.manifest.name===null||o.manifest.version===null){s.reportError(a.MessageName.UNNAMED,"Workspaces must have valid names and versions to be published on an external registry");return}let m=o.manifest.name,w=k.ppath.join(y.cwd,"dist",`${a.structUtils.slugifyIdent(m)}.tgz`);if(!await k.xfs.existsPromise(w)){s.reportError(a.MessageName.UNNAMED,`Pack package ${a.formatUtils.pretty(t,m,a.FormatType.IDENT)} first`);return}let d=await k.xfs.readFilePromise(w),l=await I(d);if(l.name==null||l.name.identHash!==m.identHash){s.reportError(a.MessageName.UNNAMED,`Tarball for package ${l.name&&a.formatUtils.pretty(t,l.name,a.FormatType.IDENT)} cannot be published in workspace for ${a.formatUtils.pretty(t,m,a.FormatType.IDENT)}`);return}let g=u.npmConfigUtils.getPublishRegistry(l,{configuration:t}),b=await u.npmPublishUtils.makePublishBody(E(o,o.cwd,l.raw),d,{access:void 0,tag:this.tag,registry:g});try{await u.npmHttpUtils.put(u.npmHttpUtils.getIdentUrl(m),b,{configuration:t,registry:g,ident:m,jsonResponse:!0})}catch(f){if(f.name!=="HTTPError")throw f;{let C=f.response.body&&f.response.body.error?f.response.body.error:`The remote server answered with HTTP ${f.response.statusCode} ${f.response.statusMessage}`;s.reportError(a.MessageName.NETWORK_ERROR,C)}}s.hasErrors()||s.reportInfo(null,`Published ${a.formatUtils.pretty(t,a.structUtils.makeDescriptor(m,l.version),a.FormatType.DESCRIPTOR)}`)})).exitCode()}};T.paths=[["snuggery-workspace","publish"]];var B={commands:process.env.SNUGGERY_YARN==="1"?[x,T]:[]},z=B;return J;})();
return plugin;
}
};
